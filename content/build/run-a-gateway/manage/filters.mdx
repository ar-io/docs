---
title: "Gateway Filters"
description: "Comprehensive guide to configuring ar.io Gateway filters for efficient data processing and indexing"
---

import { BarChart3, Database, Package, Cpu } from "lucide-react";

Configure your ar.io Gateway to efficiently process and index only the data you need. This comprehensive guide covers advanced filtering techniques, performance optimization, and real-world use cases.

## Overview

The ar.io Gateway uses a flexible JSON-based filtering system to control data processing and indexing. The system provides precise control over which bundles are processed and which data items are indexed for querying.

## Understanding the Filtering System

The ar.io Gateway uses two primary filters to control data processing:

1. **ANS104_UNBUNDLE_FILTER** - Controls which bundles are processed and unbundled
2. **ANS104_INDEX_FILTER** - Controls which data items from unbundled bundles are indexed for querying

<Callout type="info">
  By default, gateways process no bundles and index no data items. You must
  explicitly configure filters to start processing data.
</Callout>

## Core Environment Variables

<Steps>
<Step>
### Configure Data Management

Optimize data storage and processing:

```bash
# Number of new data items before flushing to stable storage
DATA_ITEM_FLUSH_COUNT_THRESHOLD=1000

# Maximum time between flushes (in seconds)
MAX_FLUSH_INTERVAL_SECONDS=600

# Maximum number of data items to queue for indexing
MAX_DATA_ITEM_QUEUE_SIZE=100000

# Enable background verification
ENABLE_BACKGROUND_DATA_VERIFICATION=true
```

</Step>

<Step>
### Set Up GraphQL Configuration

Choose between local-only or proxied queries:

```bash
# For new gateways - proxy to arweave.net for complete index
GRAPHQL_HOST=arweave.net
GRAPHQL_PORT=443

# For local-only queries (uncomment to use)
# GRAPHQL_HOST=
```

</Step>
</Steps>

## Filter Construction

<Callout type="info" title=".env formatting">
  While the filters below are displayed on multiple lines for readability, they
  must be stored in the `.env` file as a single line for proper processing.
</Callout>

### Basic Filters

The simplest filters you can use are `"always"` and `"never"` filters. The `"never"` filter is the default behavior and will match nothing, while the `"always"` filter matches everything.

<CodeGroup title="Basic Filters">
```json {{title: "Never Match"}}
{
  "never": true //default behavior
}
```

```json {{title: "Always Match"}}
{
  "always": true
}
```

</CodeGroup>

### Tag Filters

Tag filters allow you to match items based on their tags in three different ways. You can match exact tag values, check for the presence of a tag regardless of its value, or match tags whose values start with specific text. All tag values are automatically base64url-decoded before matching.

<CodeGroup title="Tag Filters">
```json {{title: "Exact Match"}}
{
  "tags": [
    {
      "name": "Content-Type",
      "value": "image/jpeg"
    }
  ]
}
```

```json {{title: "Match Tag Name Only"}}
{
  "tags": [
    {
      "name": "App-Name"
    }
  ]
}
```

```json {{title: "Starts With Match"}}
{
  "tags": [
    {
      "name": "Protocol",
      "valueStartsWith": "AO"
    }
  ]
}
```

</CodeGroup>

### Attribute Filters

Attribute filtering allows you to match items based on their metadata properties. The system automatically handles owner public key to address conversion, making it easy to filter by owner address. You can combine multiple attributes in a single filter:

<CodeGroup title="Attribute Filters">
```json {{title: "Basic Attributes"}}
{
  "attributes": {
    "owner_address": "xyz123...",
    "data_size": 1000
  }
}
```

</CodeGroup>

### Nested Bundle Filter

The `isNestedBundle` filter is a specialized filter that checks whether a data item is part of a nested bundle structure. It's particularly useful when you need to identify or process data items in bundles that are contained within other bundles.

<CodeGroup title="Nested Bundle Filter">
```json {{title: "Basic Nested Bundle"}}
{
  "isNestedBundle": true
}
```

</CodeGroup>

**Note**: When processing nested bundles, be sure to include filters that match the nested bundles in both `ANS104_UNBUNDLE_FILTER` and `ANS104_INDEX_FILTER`. The bundle data items (nested bundles) need to be indexed to be matched by the unbundle filter.

### Complex Filters Using Logical Operators

For more complex scenarios, the system provides logical operators (AND, OR, NOT) that can be combined to create sophisticated filtering patterns. These operators can be nested to any depth:

<CodeGroup title="Logical Operators">
```json {{title: "AND Operation"}}
{
  "and": [
    {
      "tags": [
        {
          "name": "App-Name",
          "value": "ArDrive-App"
        }
      ]
    },
    {
      "tags": [
        {
          "name": "Content-Type",
          "valueStartsWith": "image/"
        }
      ]
    }
  ]
}
```

```json {{title: "OR Operation"}}
{
  "or": [
    {
      "tags": [
        {
          "name": "App-Name",
          "value": "ArDrive-App"
        }
      ]
    },
    {
      "attributes": {
        "data_size": 1000
      }
    }
  ]
}
```

```json {{title: "NOT Operation"}}
{
  "not": {
    "tags": [
      {
        "name": "Content-Type",
        "value": "application/json"
      }
    ]
  }
}
```

</CodeGroup>

## Filter Configuration Strategies

<Tabs items={['Basic Filters', 'App-Specific', 'Content-Based', 'Owner-Based', 'Advanced Combinations']}>
<Tab value="Basic Filters">

### Process Everything

```json
{
  "always": true
}
```

### Process Nothing (Default)

```json
{
  "never": true
}
```

### Process Specific App Data

```json
{
  "tags": [
    {
      "name": "App-Name",
      "valueStartsWith": "MyApp"
    }
  ]
}
```

</Tab>

<Tab value="App-Specific">

### Single Application

```json
{
  "tags": [
    {
      "name": "App-Name",
      "value": "MyApp-v1.0"
    }
  ]
}
```

### Multiple Applications

```json
{
  "or": [
    {
      "tags": [
        {
          "name": "App-Name",
          "value": "MyApp-v1.0"
        }
      ]
    },
    {
      "tags": [
        {
          "name": "App-Name",
          "value": "AnotherApp-v2.1"
        }
      ]
    }
  ]
}
```

### Application with Version Range

```json
{
  "tags": [
    {
      "name": "App-Name",
      "valueStartsWith": "MyApp"
    }
  ]
}
```

</Tab>

<Tab value="Content-Based">

### Content Type Filtering

```json
{
  "tags": [
    {
      "name": "Content-Type",
      "valueStartsWith": "image/"
    }
  ]
}
```

### Specific File Types

```json
{
  "or": [
    {
      "tags": [
        {
          "name": "Content-Type",
          "value": "application/json"
        }
      ]
    },
    {
      "tags": [
        {
          "name": "Content-Type",
          "value": "text/plain"
        }
      ]
    }
  ]
}
```

### File Size Filtering

```json
{
  "attributes": {
    "data_size": 1000000
  }
}
```

</Tab>

<Tab value="Owner-Based">

### Single Owner

```json
{
  "attributes": {
    "owner_address": "YOUR_WALLET_ADDRESS"
  }
}
```

### Multiple Owners

```json
{
  "or": [
    {
      "attributes": {
        "owner_address": "WALLET_ADDRESS_1"
      }
    },
    {
      "attributes": {
        "owner_address": "WALLET_ADDRESS_2"
      }
    }
  ]
}
```

### Exclude Specific Owners

```json
{
  "not": {
    "attributes": {
      "owner_address": "UNWANTED_WALLET_ADDRESS"
    }
  }
}
```

</Tab>

<Tab value="Advanced Combinations">

### Complex Multi-Condition Filter

```json
{
  "and": [
    {
      "tags": [
        {
          "name": "App-Name",
          "valueStartsWith": "MyApp"
        }
      ]
    },
    {
      "attributes": {
        "owner_address": "YOUR_WALLET_ADDRESS"
      }
    },
    {
      "not": {
        "tags": [
          {
            "name": "Content-Type",
            "value": "application/octet-stream"
          }
        ]
      }
    }
  ]
}
```

### Exclude Common Bundlers

```json
{
  "and": [
    {
      "not": {
        "or": [
          {
            "tags": [
              {
                "name": "Bundler-App-Name",
                "value": "Warp"
              }
            ]
          },
          {
            "tags": [
              {
                "name": "Bundler-App-Name",
                "value": "Redstone"
              }
            ]
          },
          {
            "attributes": {
              "owner_address": "-OXcT1sVRSA5eGwt2k6Yuz8-3e3g9WJi5uSE99CWqsBs"
            }
          }
        ]
      }
    },
    {
      "tags": [
        {
          "name": "App-Name",
          "valueStartsWith": "MyApp"
        }
      ]
    }
  ]
}
```

</Tab>
</Tabs>

## Real-World Use Cases

### Personal Data Gateway

Perfect for individuals who want to process only their own data:

**Unbundle Filter:**

```json
{
  "and": [
    {
      "not": {
        "or": [
          {
            "tags": [
              {
                "name": "Bundler-App-Name",
                "value": "Warp"
              }
            ]
          },
          {
            "tags": [
              {
                "name": "Bundler-App-Name",
                "value": "Redstone"
              }
            ]
          }
        ]
      }
    },
    {
      "tags": [
        {
          "name": "App-Name",
          "valueStartsWith": "MyApp"
        }
      ]
    }
  ]
}
```

**Index Filter:**

```json
{
  "attributes": {
    "owner_address": "YOUR_WALLET_ADDRESS"
  }
}
```

### Application-Specific Service

Ideal for building services around specific applications:

**Unbundle Filter:**

```json
{
  "tags": [
    {
      "name": "App-Name",
      "valueStartsWith": "MyApp"
    }
  ]
}
```

**Index Filter:**

```json
{
  "or": [
    {
      "tags": [
        {
          "name": "ArFS",
          "value": "0.10"
        }
      ]
    },
    {
      "tags": [
        {
          "name": "ArFS",
          "value": "0.11"
        }
      ]
    },
    {
      "tags": [
        {
          "name": "ArFS",
          "value": "0.12"
        }
      ]
    }
  ]
}
```

### Content-Type Focused Gateway

For gateways specializing in specific content types:

**Unbundle Filter:**

```json
{
  "tags": [
    {
      "name": "Content-Type",
      "valueStartsWith": "image/"
    }
  ]
}
```

**Index Filter:**

```json
{
  "and": [
    {
      "tags": [
        {
          "name": "Content-Type",
          "valueStartsWith": "image/"
        }
      ]
    },
    {
      "attributes": {
        "data_size": 100000
      }
    }
  ]
}
```

## Performance Optimization

### Worker Configuration

<Steps>
<Step>
### Understanding Default Worker Settings

The gateway uses sensible defaults that work well for most users:

```bash
# Default values (no need to set unless customizing)
# ANS104_UNBUNDLE_WORKERS=1 (default: 0, or 1 if filters are set)
# ANS104_DOWNLOAD_WORKERS=5 (default: 5)

# Only adjust if you have specific hardware requirements
# or want to optimize for your system's capabilities
```

<Callout type="info">
  **When to Adjust Workers:** Only modify worker counts if you have
  high-performance hardware and want to maximize throughput, or if you're
  experiencing resource constraints and need to reduce load.
</Callout>

</Step>

<Step>
### Optimize Data Flushing

Balance between memory usage and database performance:

```bash
# For high-memory systems, increase threshold
DATA_ITEM_FLUSH_COUNT_THRESHOLD=2000

# For low-memory systems, decrease threshold
DATA_ITEM_FLUSH_COUNT_THRESHOLD=500

# Adjust flush interval based on data volume
MAX_FLUSH_INTERVAL_SECONDS=300
```

</Step>

<Step>
### Enable Background Processing

```bash
# Enable background verification
ENABLE_BACKGROUND_DATA_VERIFICATION=true

# Enable WAL cleanup for better performance
ENABLE_DATA_DB_WAL_CLEANUP=true
```

</Step>
</Steps>

## Webhook Filters

There are also two filters available that are used to trigger webhooks. When a transaction is processed that matches one of the webhook filters, the gateway will send a webhook to the specified `WEBHOOK_TARGET_SERVERS` urls containing the transaction data.

```bash
WEBHOOK_INDEX_FILTER=""
WEBHOOK_BLOCK_FILTER=""
```

The `WEBHOOK_INDEX_FILTER` is used to trigger a webhook when a transaction is indexed. The `WEBHOOK_BLOCK_FILTER` is used to trigger a webhook when a block is processed.

## Important Notes

- All tag names and values are base64url-decoded before matching
- Owner addresses are automatically converted from owner public keys
- Empty or undefined filters default to "never match"
- Tag matching requires all specified tags to match
- Attribute matching requires all specified attributes to match
- The filter system supports nested logical operations to any depth, allowing for very precise control over what data gets processed

## Best Practices

### Filter Design

1. **Start Simple** - Begin with basic filters and gradually add complexity
2. **Test Thoroughly** - Use `FILTER_CHANGE_REPROCESS=true` when changing filters
3. **Monitor Performance** - Watch system resources during processing
4. **Document Changes** - Keep track of filter modifications and their effects

### Maintenance

1. **Regular Monitoring** - Check gateway logs for errors and warnings
2. **Resource Cleanup** - Periodically clean up old data and logs
3. **Filter Optimization** - Refine filters based on actual data patterns
4. **Backup Configuration** - Keep copies of working filter configurations

### Troubleshooting

<Callout type="warning">
  If your gateway stops processing data after changing filters, check: - Filter
  syntax is valid JSON - Required environment variables are set - Gateway has
  been restarted after changes - System has sufficient resources
</Callout>

## Next Steps

Now that you understand gateway filtering, continue building your infrastructure:

<Cards>
  <Card
    icon={<BarChart3 className="w-8 h-8" />}
    title="Set Up Monitoring"
    description="Deploy Grafana to visualize your gateway's performance metrics"
    href="/build/extensions/grafana"
  />
  <Card
    icon={<Database className="w-8 h-8" />}
    title="Add ClickHouse"
    description="Improve query performance with ClickHouse and Parquet integration"
    href="/build/extensions/clickhouse"
  />
  <Card
    icon={<Package className="w-8 h-8" />}
    title="Deploy Bundler"
    description="Accept data uploads directly through your gateway"
    href="/build/extensions/bundler"
  />
  <Card
    icon={<Cpu className="w-8 h-8" />}
    title="Run Compute Unit"
    description="Execute AO processes locally for maximum efficiency"
    href="/build/extensions/compute-unit"
  />
</Cards>
